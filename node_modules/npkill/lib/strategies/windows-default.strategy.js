"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WindowsDefaultStrategy = void 0;
const fs_1 = require("fs");
const constants_1 = require("@core/constants");
const windows_strategy_abstract_1 = require("./windows-strategy.abstract");
const path_1 = require("path");
class WindowsDefaultStrategy extends windows_strategy_abstract_1.WindowsStrategy {
    remove(dirOrFilePath, callback) {
        fs_1.lstat(dirOrFilePath, (lstatError, stats) => {
            //  No such file or directory - Done
            if (lstatError && lstatError.code === 'ENOENT') {
                return callback(null);
            }
            if (stats.isDirectory()) {
                return this.removeDirectory(dirOrFilePath, callback);
            }
            fs_1.unlink(dirOrFilePath, (rmError) => {
                //  No such file or directory - Done
                if (rmError && rmError.code === 'ENOENT') {
                    return callback(null);
                }
                if (rmError && rmError.code === 'EISDIR') {
                    return this.removeDirectory(dirOrFilePath, callback);
                }
                callback(rmError);
            });
        });
        return true;
    }
    isSupported() {
        return true;
    }
    removeDirectory(path, callback) {
        fs_1.rmdir(path, (rmDirError) => {
            //  We ignore certain error codes
            //  in order to simulate 'recursive' mode
            if (rmDirError &&
                constants_1.RECURSIVE_RMDIR_IGNORED_ERROR_CODES.includes(rmDirError.code)) {
                return this.removeChildren(path, callback);
            }
            callback(rmDirError);
        });
    }
    removeChildren(path, callback) {
        fs_1.readdir(path, (readdirError, ls) => {
            if (readdirError) {
                return callback(readdirError);
            }
            let contentInDirectory = ls.length;
            let done = false;
            //  removeDirectory only allows deleting directories
            //  that has no content inside (empty directory).
            if (!contentInDirectory) {
                return fs_1.rmdir(path, callback);
            }
            ls.forEach((dirOrFile) => {
                const dirOrFilePath = path_1.join(path, dirOrFile);
                this.remove(dirOrFilePath, (error) => {
                    if (done) {
                        return;
                    }
                    if (error) {
                        done = true;
                        return callback(error);
                    }
                    contentInDirectory--;
                    //  No more content inside.
                    //  Remove the directory.
                    if (!contentInDirectory) {
                        fs_1.rmdir(path, callback);
                    }
                });
            });
        });
    }
}
exports.WindowsDefaultStrategy = WindowsDefaultStrategy;
